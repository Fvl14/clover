# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package citrusleaf;
use base qw(Exporter);
use base qw(DynaLoader);
package citrusleafc;
bootstrap citrusleaf;
package citrusleaf;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package citrusleaf;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package citrusleaf;

*cdata = *citrusleafc::cdata;
*memmove = *citrusleafc::memmove;
*new_intp = *citrusleafc::new_intp;
*copy_intp = *citrusleafc::copy_intp;
*delete_intp = *citrusleafc::delete_intp;
*intp_assign = *citrusleafc::intp_assign;
*intp_value = *citrusleafc::intp_value;
*new_cl_bin_p = *citrusleafc::new_cl_bin_p;
*copy_cl_bin_p = *citrusleafc::copy_cl_bin_p;
*delete_cl_bin_p = *citrusleafc::delete_cl_bin_p;
*cl_bin_p_assign = *citrusleafc::cl_bin_p_assign;
*cl_bin_p_value = *citrusleafc::cl_bin_p_value;
*new_charp = *citrusleafc::new_charp;
*copy_charp = *citrusleafc::copy_charp;
*delete_charp = *citrusleafc::delete_charp;
*charp_assign = *citrusleafc::charp_assign;
*charp_value = *citrusleafc::charp_value;
*new_cf_digest_p = *citrusleafc::new_cf_digest_p;
*copy_cf_digest_p = *citrusleafc::copy_cf_digest_p;
*delete_cf_digest_p = *citrusleafc::delete_cf_digest_p;
*cf_digest_p_assign = *citrusleafc::cf_digest_p_assign;
*cf_digest_p_value = *citrusleafc::cf_digest_p_value;
*citrusleaf_init = *citrusleafc::citrusleaf_init;
*citrusleaf_shutdown = *citrusleafc::citrusleaf_shutdown;
*citrusleaf_cluster_create = *citrusleafc::citrusleaf_cluster_create;
*citrusleaf_cluster_use_nbconnect = *citrusleafc::citrusleaf_cluster_use_nbconnect;
*citrusleaf_cluster_add_host = *citrusleafc::citrusleaf_cluster_add_host;
*citrusleaf_cluster_destroy = *citrusleafc::citrusleaf_cluster_destroy;
*cl_write_parameters_set_default = *citrusleafc::cl_write_parameters_set_default;
*citrusleaf_object_init = *citrusleafc::citrusleaf_object_init;
*citrusleaf_object_init_str = *citrusleafc::citrusleaf_object_init_str;
*citrusleaf_object_init_str2 = *citrusleafc::citrusleaf_object_init_str2;
*citrusleaf_object_init_blob = *citrusleafc::citrusleaf_object_init_blob;
*citrusleaf_object_init_blob2 = *citrusleafc::citrusleaf_object_init_blob2;
*citrusleaf_object_init_int = *citrusleafc::citrusleaf_object_init_int;
*citrusleaf_object_init_null = *citrusleafc::citrusleaf_object_init_null;
*citrusleaf_put = *citrusleafc::citrusleaf_put;
*citrusleaf_get = *citrusleafc::citrusleaf_get;
*citrusleaf_get_all = *citrusleafc::citrusleaf_get_all;
*citrusleaf_get_digest = *citrusleafc::citrusleaf_get_digest;
*citrusleaf_put_digest = *citrusleafc::citrusleaf_put_digest;
*citrusleaf_delete_digest = *citrusleafc::citrusleaf_delete_digest;
*citrusleaf_delete = *citrusleafc::citrusleaf_delete;
*get_name = *citrusleafc::get_name;
*get_object = *citrusleafc::get_object;
*citrusleaf_bins_free = *citrusleafc::citrusleaf_bins_free;
*citrusleaf_batch_get = *citrusleafc::citrusleaf_batch_get;
*citrusleaf_calculate_digest = *citrusleafc::citrusleaf_calculate_digest;
*free = *citrusleafc::free;
*citrusleaf_free_bins = *citrusleafc::citrusleaf_free_bins;
*citrusleaf_operate = *citrusleafc::citrusleaf_operate;
*citrusleaf_use_shm = *citrusleafc::citrusleaf_use_shm;
*citrusleaf_async_initialize = *citrusleafc::citrusleaf_async_initialize;
*citrusleaf_async_put_forget = *citrusleafc::citrusleaf_async_put_forget;
*citrusleaf_async_put_digest_forget = *citrusleafc::citrusleaf_async_put_digest_forget;

############# Class : citrusleaf::cl_bin_arr ##############

package citrusleaf::cl_bin_arr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( citrusleaf );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = citrusleafc::new_cl_bin_arr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        citrusleafc::delete_cl_bin_arr($self);
        delete $OWNER{$self};
    }
}

*getitem = *citrusleafc::cl_bin_arr_getitem;
*setitem = *citrusleafc::cl_bin_arr_setitem;
*cast = *citrusleafc::cl_bin_arr_cast;
*frompointer = *citrusleafc::cl_bin_arr_frompointer;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : citrusleaf::cf_digest_arr ##############

package citrusleaf::cf_digest_arr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( citrusleaf );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = citrusleafc::new_cf_digest_arr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        citrusleafc::delete_cf_digest_arr($self);
        delete $OWNER{$self};
    }
}

*getitem = *citrusleafc::cf_digest_arr_getitem;
*setitem = *citrusleafc::cf_digest_arr_setitem;
*cast = *citrusleafc::cf_digest_arr_cast;
*frompointer = *citrusleafc::cf_digest_arr_frompointer;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : citrusleaf::cl_record_arr ##############

package citrusleaf::cl_record_arr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( citrusleaf );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = citrusleafc::new_cl_record_arr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        citrusleafc::delete_cl_record_arr($self);
        delete $OWNER{$self};
    }
}

*getitem = *citrusleafc::cl_record_arr_getitem;
*setitem = *citrusleafc::cl_record_arr_setitem;
*cast = *citrusleafc::cl_record_arr_cast;
*frompointer = *citrusleafc::cl_record_arr_frompointer;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : citrusleaf::cl_op_arr ##############

package citrusleaf::cl_op_arr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( citrusleaf );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = citrusleafc::new_cl_op_arr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        citrusleafc::delete_cl_op_arr($self);
        delete $OWNER{$self};
    }
}

*getitem = *citrusleafc::cl_op_arr_getitem;
*setitem = *citrusleafc::cl_op_arr_setitem;
*cast = *citrusleafc::cl_op_arr_cast;
*frompointer = *citrusleafc::cl_op_arr_frompointer;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : citrusleaf::cl_record ##############

package citrusleaf::cl_record;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( citrusleaf );
%OWNER = ();
%ITERATORS = ();
*swig_gen_get = *citrusleafc::cl_record_gen_get;
*swig_gen_set = *citrusleafc::cl_record_gen_set;
*swig_bin_get = *citrusleafc::cl_record_bin_get;
*swig_bin_set = *citrusleafc::cl_record_bin_set;
*swig_ns_get = *citrusleafc::cl_record_ns_get;
*swig_ns_set = *citrusleafc::cl_record_ns_set;
*swig_set_get = *citrusleafc::cl_record_set_get;
*swig_set_set = *citrusleafc::cl_record_set_set;
*swig_record_ttl_get = *citrusleafc::cl_record_record_ttl_get;
*swig_record_ttl_set = *citrusleafc::cl_record_record_ttl_set;
*swig_n_bins_get = *citrusleafc::cl_record_n_bins_get;
*swig_n_bins_set = *citrusleafc::cl_record_n_bins_set;
*swig_digest_get = *citrusleafc::cl_record_digest_get;
*swig_digest_set = *citrusleafc::cl_record_digest_set;
sub new {
    my $pkg = shift;
    my $self = citrusleafc::new_cl_record(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        citrusleafc::delete_cl_record($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : citrusleaf::BatchResult ##############

package citrusleaf::BatchResult;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( citrusleaf );
%OWNER = ();
%ITERATORS = ();
*swig_records_get = *citrusleafc::BatchResult_records_get;
*swig_records_set = *citrusleafc::BatchResult_records_set;
*swig_index_get = *citrusleafc::BatchResult_index_get;
*swig_index_set = *citrusleafc::BatchResult_index_set;
*swig_rv_get = *citrusleafc::BatchResult_rv_get;
*swig_rv_set = *citrusleafc::BatchResult_rv_set;
sub new {
    my $pkg = shift;
    my $self = citrusleafc::new_BatchResult(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        citrusleafc::delete_BatchResult($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : citrusleaf::cf_digest ##############

package citrusleaf::cf_digest;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( citrusleaf );
%OWNER = ();
%ITERATORS = ();
*swig_digest_get = *citrusleafc::cf_digest_digest_get;
*swig_digest_set = *citrusleafc::cf_digest_digest_set;
sub new {
    my $pkg = shift;
    my $self = citrusleafc::new_cf_digest(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        citrusleafc::delete_cf_digest($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : citrusleaf::cl_bin ##############

package citrusleaf::cl_bin;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( citrusleaf );
%OWNER = ();
%ITERATORS = ();
*swig_bin_name_get = *citrusleafc::cl_bin_bin_name_get;
*swig_bin_name_set = *citrusleafc::cl_bin_bin_name_set;
*swig_object_get = *citrusleafc::cl_bin_object_get;
*swig_object_set = *citrusleafc::cl_bin_object_set;
sub new {
    my $pkg = shift;
    my $self = citrusleafc::new_cl_bin(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        citrusleafc::delete_cl_bin($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : citrusleaf::cl_object ##############

package citrusleaf::cl_object;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( citrusleaf );
%OWNER = ();
%ITERATORS = ();
*swig_type_get = *citrusleafc::cl_object_type_get;
*swig_type_set = *citrusleafc::cl_object_type_set;
*swig_sz_get = *citrusleafc::cl_object_sz_get;
*swig_sz_set = *citrusleafc::cl_object_sz_set;
*swig_free_get = *citrusleafc::cl_object_free_get;
*swig_free_set = *citrusleafc::cl_object_free_set;
*swig_u_get = *citrusleafc::cl_object_u_get;
*swig_u_set = *citrusleafc::cl_object_u_set;
sub new {
    my $pkg = shift;
    my $self = citrusleafc::new_cl_object(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        citrusleafc::delete_cl_object($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : citrusleaf::cl_object_u ##############

package citrusleaf::cl_object_u;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( citrusleaf );
%OWNER = ();
%ITERATORS = ();
*swig_str_get = *citrusleafc::cl_object_u_str_get;
*swig_str_set = *citrusleafc::cl_object_u_str_set;
*swig_blob_get = *citrusleafc::cl_object_u_blob_get;
*swig_blob_set = *citrusleafc::cl_object_u_blob_set;
*swig_i64_get = *citrusleafc::cl_object_u_i64_get;
*swig_i64_set = *citrusleafc::cl_object_u_i64_set;
sub new {
    my $pkg = shift;
    my $self = citrusleafc::new_cl_object_u(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        citrusleafc::delete_cl_object_u($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : citrusleaf::cl_write_parameters ##############

package citrusleaf::cl_write_parameters;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( citrusleaf );
%OWNER = ();
%ITERATORS = ();
*swig_unique_get = *citrusleafc::cl_write_parameters_unique_get;
*swig_unique_set = *citrusleafc::cl_write_parameters_unique_set;
*swig_unique_bin_get = *citrusleafc::cl_write_parameters_unique_bin_get;
*swig_unique_bin_set = *citrusleafc::cl_write_parameters_unique_bin_set;
*swig_use_generation_get = *citrusleafc::cl_write_parameters_use_generation_get;
*swig_use_generation_set = *citrusleafc::cl_write_parameters_use_generation_set;
*swig_use_generation_gt_get = *citrusleafc::cl_write_parameters_use_generation_gt_get;
*swig_use_generation_gt_set = *citrusleafc::cl_write_parameters_use_generation_gt_set;
*swig_use_generation_dup_get = *citrusleafc::cl_write_parameters_use_generation_dup_get;
*swig_use_generation_dup_set = *citrusleafc::cl_write_parameters_use_generation_dup_set;
*swig_generation_get = *citrusleafc::cl_write_parameters_generation_get;
*swig_generation_set = *citrusleafc::cl_write_parameters_generation_set;
*swig_timeout_ms_get = *citrusleafc::cl_write_parameters_timeout_ms_get;
*swig_timeout_ms_set = *citrusleafc::cl_write_parameters_timeout_ms_set;
*swig_record_ttl_get = *citrusleafc::cl_write_parameters_record_ttl_get;
*swig_record_ttl_set = *citrusleafc::cl_write_parameters_record_ttl_set;
*swig_w_pol_get = *citrusleafc::cl_write_parameters_w_pol_get;
*swig_w_pol_set = *citrusleafc::cl_write_parameters_w_pol_set;
sub new {
    my $pkg = shift;
    my $self = citrusleafc::new_cl_write_parameters(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        citrusleafc::delete_cl_write_parameters($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : citrusleaf::cl_operation ##############

package citrusleaf::cl_operation;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( citrusleaf );
%OWNER = ();
%ITERATORS = ();
*swig_bin_get = *citrusleafc::cl_operation_bin_get;
*swig_bin_set = *citrusleafc::cl_operation_bin_set;
*swig_op_get = *citrusleafc::cl_operation_op_get;
*swig_op_set = *citrusleafc::cl_operation_op_set;
sub new {
    my $pkg = shift;
    my $self = citrusleafc::new_cl_operation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        citrusleafc::delete_cl_operation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- CONSTANT STUBS -------

package citrusleaf;

sub CL_NULL () { $citrusleafc::CL_NULL }
sub CL_INT () { $citrusleafc::CL_INT }
sub CL_FLOAT () { $citrusleafc::CL_FLOAT }
sub CL_STR () { $citrusleafc::CL_STR }
sub CL_BLOB () { $citrusleafc::CL_BLOB }
sub CL_TIMESTAMP () { $citrusleafc::CL_TIMESTAMP }
sub CL_DIGEST () { $citrusleafc::CL_DIGEST }
sub CL_JAVA_BLOB () { $citrusleafc::CL_JAVA_BLOB }
sub CL_CSHARP_BLOB () { $citrusleafc::CL_CSHARP_BLOB }
sub CL_PYTHON_BLOB () { $citrusleafc::CL_PYTHON_BLOB }
sub CL_RUBY_BLOB () { $citrusleafc::CL_RUBY_BLOB }
sub CL_PHP_BLOB () { $citrusleafc::CL_PHP_BLOB }
sub CL_UNKNOWN () { $citrusleafc::CL_UNKNOWN }
sub CITRUSLEAF_FAIL_ASYNCQ_FULL () { $citrusleafc::CITRUSLEAF_FAIL_ASYNCQ_FULL }
sub CITRUSLEAF_FAIL_TIMEOUT () { $citrusleafc::CITRUSLEAF_FAIL_TIMEOUT }
sub CITRUSLEAF_FAIL_CLIENT () { $citrusleafc::CITRUSLEAF_FAIL_CLIENT }
sub CITRUSLEAF_OK () { $citrusleafc::CITRUSLEAF_OK }
sub CITRUSLEAF_FAIL_UNKNOWN () { $citrusleafc::CITRUSLEAF_FAIL_UNKNOWN }
sub CITRUSLEAF_FAIL_NOTFOUND () { $citrusleafc::CITRUSLEAF_FAIL_NOTFOUND }
sub CITRUSLEAF_FAIL_GENERATION () { $citrusleafc::CITRUSLEAF_FAIL_GENERATION }
sub CITRUSLEAF_FAIL_PARAMETER () { $citrusleafc::CITRUSLEAF_FAIL_PARAMETER }
sub CITRUSLEAF_FAIL_KEY_EXISTS () { $citrusleafc::CITRUSLEAF_FAIL_KEY_EXISTS }
sub CITRUSLEAF_FAIL_BIN_EXISTS () { $citrusleafc::CITRUSLEAF_FAIL_BIN_EXISTS }
sub CITRUSLEAF_FAIL_CLUSTER_KEY_MISMATCH () { $citrusleafc::CITRUSLEAF_FAIL_CLUSTER_KEY_MISMATCH }
sub CITRUSLEAF_FAIL_PARTITION_OUT_OF_SPACE () { $citrusleafc::CITRUSLEAF_FAIL_PARTITION_OUT_OF_SPACE }
sub CITRUSLEAF_FAIL_SERVERSIDE_TIMEOUT () { $citrusleafc::CITRUSLEAF_FAIL_SERVERSIDE_TIMEOUT }
sub CITRUSLEAF_FAIL_NOXDS () { $citrusleafc::CITRUSLEAF_FAIL_NOXDS }
sub CITRUSLEAF_FAIL_UNAVAILABLE () { $citrusleafc::CITRUSLEAF_FAIL_UNAVAILABLE }
sub CITRUSLEAF_FAIL_INCOMPATIBLE_TYPE () { $citrusleafc::CITRUSLEAF_FAIL_INCOMPATIBLE_TYPE }
sub CITRUSLEAF_FAIL_RECORD_TOO_BIG () { $citrusleafc::CITRUSLEAF_FAIL_RECORD_TOO_BIG }
sub CITRUSLEAF_FAIL_KEY_BUSY () { $citrusleafc::CITRUSLEAF_FAIL_KEY_BUSY }
sub CL_OP_WRITE () { $citrusleafc::CL_OP_WRITE }
sub CL_OP_READ () { $citrusleafc::CL_OP_READ }
sub CL_OP_INCR () { $citrusleafc::CL_OP_INCR }
sub CL_OP_MC_INCR () { $citrusleafc::CL_OP_MC_INCR }
sub CL_OP_PREPEND () { $citrusleafc::CL_OP_PREPEND }
sub CL_OP_APPEND () { $citrusleafc::CL_OP_APPEND }
sub CL_OP_MC_PREPEND () { $citrusleafc::CL_OP_MC_PREPEND }
sub CL_OP_MC_APPEND () { $citrusleafc::CL_OP_MC_APPEND }
sub CL_OP_TOUCH () { $citrusleafc::CL_OP_TOUCH }
sub CL_OP_MC_TOUCH () { $citrusleafc::CL_OP_MC_TOUCH }

# ------- VARIABLE STUBS --------

package citrusleaf;

1;
